阅读需要有一定基础，一些点由于原因很容易看出来就没有写。

1、long不一定是64位，char在一些机器上有符号在一些机器上没有。尽量避免依赖于实现环境的编码

2、切勿混用带符合数和无符号数

3、以0开头为八进制数

4、8进制和16进制的字面值的类型是能容纳其数值的int、uint、long、ulong、longlong、ulonglong中的最小者，否则产生错误

5、默认的浮点数字面值是个double而非float

6、双引号括起来的称为字符串字面值，字符串字面值实际是常量字符构成的数组，其实际长度比内容多1

7、两类字符无法直接使用：不可打印字符、特殊含义字符（引号等），需要使用/进行转移

8、wchar_t用于扩展字符集，确保可以存放机器最大扩展字符集的任意一个；char16_t、char32_t用于存放unicode字符集。unicode是表示所有自然语言字符中的标准

9、前缀和后缀

![image-20250705005419016](https://raw.githubusercontent.com/t1m3saver/picBed/main/mac/image-20250705005419016.png)

10、泛化的转义序列两种形式，分别用8进制和16进制：16进制的话\x后跟一个或者多个16进制数；8进制的话\后面跟1、2、3个8进制数字

11、什么是变量？“提供一个具名的，可以供程序操作的存储空间”

12、什么是对象？对象是指一块能存储数据并且具有某种类型的内存空间

13、什么是初始化？当对象在创建的时候获得了一个特定的值，称其被初始化了

14、初始化和赋值是完全不同的操作，不可混为一谈；赋值的含义是指把对象当前的值擦除，而以一个新值代替

15、列表初始化在cpp11标准之后，开始全面应用。为什么用它呢？特点在于，用列表初始化并且初始化的值存在丢失信息的风险的时候，编译器会报错。

![image-20250705010945733](https://raw.githubusercontent.com/t1m3saver/picBed/main/mac/image-20250705010945733.png)

16、默认初始化。当定义变量没有指定初始值，就被默认初始化。定义变量的位置会影响，对内置类型来说，如果是在函数体内，那么值未定义；定义在任何函数体之外的，初始化为0；

17、声明和定义的关系

为了允许程序能被拆分成多个文件来编写，cpp支持分离式编译。也就是运行程序分为若干文件，每个文件可以被独立的编译。那么就需要有一个不同文件之间共享代码的方式，为此cpp将声明和定义区别开。

声明：使得名字为程序所知

定义：负责创建与名字相关联的实体

声明规定了类型的名称和类型，在这一点上，定义和声明一样。但关键差异在于，定义还会申请内存空间，也可能为变量赋初始值。

18、要声明一个变量而非定义它，使用extern并且不要显式地初始化它。

19、“任何包含了显示初始化的声明即为定义”

20、变量可以被多次声明，但只能定义一次

21、cpp是静态类型语言，其在编译阶段检查类型，称为类型检查。有助于我们提前发现问题

22、cpp其实提供了操作符的替代名称

![image-20250705012817458](https://raw.githubusercontent.com/t1m3saver/picBed/main/mac/image-20250705012817458.png)

23、作用域中一旦声明了某个名字，它所嵌套的所有作用域都能访问该名字；允许在内层作用域重新定义外层作用域已经有的名字

24、什么是复合类型：基于其他类型定义的类型；指针、引用

25、引用即是别名，它不是对象，它只是为一个已经存在的对象所起的另外一个名字而已。引用只能绑定在对象上，不能与字面值、表达式的计算结果绑定，而且引用的类型需要与之要绑定的对象严格匹配（除了两种例外情况，后面会写）

例外：初始化常量引用的时候运行任意表达式作为初始值，只要其能被转为引用的类型（这个时候编译器会提供一个const的对应引用类型的临时量，这也是为什么必须是常量的引用，否则就会涉及到修改临时量了）

26、因为引用不是对象，所以不能定义引用的引用

27、指针和引用的区别：

1、指针本身就是个对象，因此允许对指针进行赋值和拷贝，而且在指针的生命周期内可以先后指向不同的对象

2、指针不需要在定义的时候赋初始值。块作用域内定义的指针值不确定，非块作用域的指针为nullptr

28、因为引用不是对象，所以无法定义指向引用的指针

29、nullptr是一个特殊的字面值，可以被转换为任意其他的指针类型

30、任何非0指针对应的条件值都是true

31、引用本身不是对象，所以无法定义指向引用的指针；指针是对象，所以可以定义对指针的引用

32、因为const对象创建以后就无法再改变，所以必须初始化，初始值可以是任意复杂的表达式

33、const对象只在当前文件内有效。编译器在编译过程中将用到这个变量的地方替换为const的值，为此，编译器需要找到变量的初始值，如果程序有多个文件，那么每个程序都要访问到它的初始值才行，那么每一个用到这个变量的地方都要有对他的定义。const被设定在单个文件内有效，如果有多个文件出现同名的const，其实等同于不同文件中分别定义了**独立的变量**

也就是说，当你在hpp中定义了一个const值，其他cpp都include这个头文件的时候，每个cpp文件其实是自己独立定义了一份

- const **默认 internal linkage**，也就是**每个 cpp 文件看到的其实是“私有的 MY_CONST”**，它们没有暴露给链接器；
- 所以链接器不会报“重复定义”，但你实际上定义了多个副本

解决方法：头文件中用extern声明变量，cpp中extern定义并且初始化变量（cpp中其他文件要用必须用extern）

cpp17之后推荐用法

```
// config.hpp
#pragma once
inline constexpr int MY_CONST = 42;  // C++17 起推荐做法
```

34、使用const引用的时候需要注意，你引用的东西完全可能被其他地方修改。指向常量的指针也是一样。这些都是他们“自以为是”地以为自己指向了常量，所以自觉地不去修改所指对象的值

35、想存放常量对象的地址，就必须是指向常量的指针

36、因为指针是对象而引用不是，所以可以把指针本身定为常量。我们可以见到const int * const ptr = address却看不到const int & const refer = value；

37、常量表达式：值不会变 并且 在编译器就可以计算得到结果的

38、cpp允许将变量声明为constexpr类型以**由编译器验证**变量的值是不是一个常量表达式

建议：只要你认为一个变量是一个常量表达式，就可以用constexpr

新标准还运行你用constexpr定义一个特殊的函数，这个函数应该简单到编译器就可以计算出结果然后用它赋值给constexpr变量

39、声明constexpr时候的类型必须是字面值类型。算术类型、引用和指针都是。但是自己定义的类、string不是。指针必须初始化为nullptr或者0或者存储于某个固定地址的对象

40、函数体内的变量一般并非在固定地址，因此constexpr指针不准指向他们。定义于函数体外的对象地址不变，可以用来初始化constexpr指针。

41、constexpr如果定义了一个指针，那么只是说这个指针本身不可变

42、用类型别名到声明语句中需要注意以防产生意想不到的后果比如曲解：

```
typedef char* pstring;

const pstring cstr = 0;(cstr是指向char的常量指针而非指向const char的指针)

const pstring *ps;（ps是一个指针，它的对象是指向的是一个指向char的常量指针。而非：ps是一个指针，它的对象是一个指向const char的指针）
```

关键点在于：不要把typedef里面的东西直接带进表达式去理解，而是查看typedef的定义

43、auto会忽略顶层const，保留底层const

44、decltype：有时候希望从表达式的类型推断出要定义的变量的类型又不想用这个表达式初始化这个变量

其能返回操作数的数据类型，编译器分析表达式的类型但是不计算它的值

45、decltype和auto不一样，它不会抛弃顶层const，引用也不会被抛弃。引用一直被作为其所指对象的同义词，只有用在decltype才是例外

46、r是一个引用，可以用decltype(包含r的表达式)来定义变量来舍弃引用性

47、解引用指针实际得到的指针所指的对象，也因此decltype(*p)的时候，其实是引用类型！而非一般类型

48、给变量加不加括号放在decltype中得到的结果完全不同！如果给变量多加了一层括号或者多层括号，编译器会把他当做表达式，变量是一种可以作为赋值语句左值的特殊表达式，因为这样的decltype会得到**引用类型**

decltype((i)) d;// 错误，d是int&，需要初始化

49、decltype((变量))的结果永远是引用，而decltype(变量)只有在变量本身是引用的时候才是

50、赋值是会产生引用类型的典型表达式，引用的类型就是左值的类型，也就说，如果i是int，那么i=x的类型就是int&

**为什么赋值表达式返回引用类型？**

因为这是为了支持**链式赋值**：

```
a = b = c = d;
```

51、为什么类和结构体后面需要加分号：因为其后可以紧跟变量名以示对一个变量进行定义

52、cpp11开始，可以给类数据成员以初始值，花括号以及等号都可以的。否则被默认初始化。

53、为了要在不同文件中使用同一个类，就需要把类定义保持一致，为了保证各个文件中的类定义一致，类通常被**定义**在头文件中。头文件通常包含那些**只能被定义一次**的实体

54、关注头文件重复包含的问题：你自己定义的类里面用到了string，因此需要引入string的头文件，而使用你的类的地方可能自己也需要使用string，因此那个地方也引入了string头文件。所以string头文件实际上在那个地方被引了两次，string自己做了处理所以没有问题，我们自己也要处理这种可能被重复引用的情况

55、预处理器可以确保不同头文件多次包含仍然能安全工作。**头文件保护符**会被其使用，头文件保护符依赖于未处理变量，预处理变量有两种状态，已定义和未定义。

```
#define 把一个变量设定为预处理变量

#ifdef  判断变量已经定义则为真

#ifndef 判断变量未定义为真

#endif 执行检查结果为真中的操作直到这个停止
```

用法就是

```
#ifndef XXX_XX_H 
#define XXX_XX_H 
头文件定义
#endif
```

56、**预处理变量无视cpp语言中关于作用域的规则**。为此头文件保护符需要保持唯一。

57、#pragma once可以完全平替头文件保护符

58、头文件不应包含using声明，因为头文件的内容会被拷贝到所有引用到它的文件中去，如果文件有某个using，所有使用了这个头文件中的文件都会有这个声明

59、string s("value"); 这里的s是value的副本，除了字面值最后的空字符

60、注意string的拷贝初始化和直接初始化的区别，用=是拷贝

61、一个表达式里面已经有size()函数之后就不要用int了，避免混用无符号数和无符号数的运算

62、字面值和string对象相加的时候，必须保证字面值左右两侧至少有一个string对象。字面值其实与string是不同的类型

63、不要再造轮子，cctype头文件已经包含了对单个字符的各种判断

![image-20250706115644447](https://raw.githubusercontent.com/t1m3saver/picBed/main/mac/image-20250706115644447.png)

64、模版本身不是类或者函数，可以把模版看成是编译器生成类或者函数编写的**一份说明**。编译器根据模版创建类或者函数的过程被称为**实例化**

vector是模版而非类型