# Java核心技术卷一，学习笔记

纪要：该笔记汇聚了全部的Java核心技术卷一书中提及的关键点、包括和cpp中各个语法的对比，完全碾压市面上全部Java语法类的八股文知识点。

## 1、java都是值传递的

只是java的对象可以类比于c++中的对象指针，因此函数中传入一个java对象确实可以修改这个对象的实际内容；但是无法swap两个对象的内容，因为按值传递的原因，当你按swap(a,b)调用下面的函数的时候，尽管函数里面的x和y分别指向了另一个对象，但是外界的a和b仍然指向最初的对象

![image-20250405144856513](https://i-blog.csdnimg.cn/img_convert/b8cf7b3e4446aa2d27ea0228604df2ba.png)

## 2、java的初始化默认值

数值为0，boolean为false，对象为null

## 3、java只有堆对象，没有栈对象

Java 不允许你写栈上对象，**没有 `MyClass obj;` 这样的行为**，所有对象都要通过 `new`

## 4、java没有初始化成员列表的构造方法

## 5、java程序员通常不在成员变量前加上m_等标识

## 6、java允许在构造函数中调用同一个类的另一个构造函数，cpp不允许

## 7、java提供初始化块在构造函数之前执行，静态初始化块在类第一次加载的时候执行

## 8、java自动完成垃圾回收，因此不支持析构函数。如果需要使用资源之后立即关闭，则提供close方法；不要调用finalize方法，其已经废弃

## 9、一个类可以使用同一个包下面的所有类、其他包的公共类。package和import类似于namespace和using

## 10、java提供静态导入import static，这样使用静态方法的时候无需指定类

## 11、java的类得放在包名对应的位置上，否则编译没有问题（如果不依赖其他包），但是运行的时候java虚拟机会找不到类

## 12、JAR文件是java归档文件（ZIP格式），里面可以包含多个压缩形式的类文件和子目录，可以节省空间、改善性能

## 13、没有指定public、private的类 方法和变量可以被同一个包访问

## 14、java的类路径，大概是为了方便编译器和虚拟机查找对应的类文件。包含三个部分，分别是类目录、当前目录、jar目录。这其实关乎到加载顺序。

当**虚拟机**要查找一个类的类文件的时候，先查找Java A中的类。然后查找”类目录“+ 待查找类的路径的文件、查找当前目录下面+待查找类的路径文件、查找jar目录+待查找类路径的文件

当编译器要查找一个类文件的时候，如果引用了一个类，那么编译器先查找包含这个类的包，会查看所有的import命令以确定其中是否包含这个类。

![image-20250406194503026](https://i-blog.csdnimg.cn/img_convert/8476a6422aeb499df3076195cf7cf1f4.png)

## 15、Jar文件

将应用程序以Jar的形式打包运行

创建jar文件

```
jar cvf xxx.jar *.class 
```

每一个jar文件中还有一个清单文件manifest，目的是描述这个归档文件的特殊特性。

MANIFEST.MF，位于一个特殊目录，META-INF

```
jar cfm创建清单文件并且
jar ufm更新一个已有的jar文件
```

```
使用-e选项指定jar文件的可执行程序的主类
jar cvfe xxx.jar com.MainClass
```

## 16、所有的java继承都是public继承

## 17、java用super调用基类构造或者其他方法，而cpp用：：。构造函数的时候cpp用初始化成员列表调父类构造函数

## 18、java中嵌套的包对编译器而言没有任何关系

## 19、只能使用*导入一个包

## 20、#include和import没有任何相同之处，cpp编译器无法查看除了当前文件以及其头文件中明确保护的文件以外的任何文件。java编译器则可以查看其他文件，只需要告诉在哪，因此用全名可以完全替代import

## 21、extends表明继承关系，派生一个已经存在的类。称其为基类、超类、父类。其关系为is-a

## 22、super只是指示编译器调用超类方法的特殊关键字

## 23、多态：一个对象变量可以指示多种实际类型的现象

## 24、理解java的方法调用过程是什么

1、编译器查看对象的声明类型和方法名。会列出所有当前声明对象的类中所有名称f对应1的方法、基类中名称一样并且public的方法

2、确定调用的参数类型，以决定调用哪个方法。可能发生类型转换，失败就抛异常（返回类型不是函数签名的一部分）

3、如果是私有方法、static方法、final方法、构造方法，那么编译器可以准确找到调用哪个方法，称为静态绑定

4、否则就需要动态绑定，先查找当前对象对应的该方法、然后逐层查询基类的方法

5、为减缓开销编译器生成了一个方法表，只需要查看这个方法表就能找到合适的方法

## 25、子类方法不能低于父类方法的可见性

## 26、使用final类和方法来阻止继承

类这样声明：子类无法覆盖该方法

函数：子类无法再覆写该方法

字段：无法再改造他们的值

如果一个类是final，那么方法默认final、字段不是final的

## 27、使用final可以避免动态绑定

一个很短、未被覆盖的方法会被内联优化。当前虚拟机还有即使编译器，能准确知道类的继承关系、检测方法是否被覆盖（方法是否简单、调用次数是否多）并且决定是否内联方法



## 28、java的强制类型转换，就是加个（类型）

子类给父类是不需要的，如果在继承链上进行向下的强制类型转换失败则抛‘ClassCastException

可以用instanceof判断是否能转换

## 29、存在抽象方法就必须声明为抽象类、不含抽象方法也可以声明为抽象类、抽象类无法实例化、可以声明抽象类的对象变量

## 30、和cpp不一样，java的protected可见性是整个包以及子类，安全性更差

## 31、和cpp不一样，不声明访问修饰符的时候默认对包内可见的

## 32、java中，只有基本数值类型不是对象，其他全是

## 33、object类默认的equals方法是判断两个对象的相等。但是有时候我们希望两对象如果是各个字段都相等也是相等的，则需要重写equals的方法，先判断是否是同一对象是则立即返回、再依次判断各个值

## 34、子类的equals方法先调用基类的equals方法

## 35、关于hashCode方法，由于String的散列码是根据内容导出的，所以只要内存一样就是一样的。而StringBuilder没有定义hashCode方法，其使用的Object的默认的hashCode方法是由对象的地址导出的

## 36、如果重新定义了equals方法，那么就要“为可能加入散列表”的对象重新定义hashCode方法

## 37、hashCode方法可以通过调用Objects.hash（各个属性值）来实现，它会为每个参数调用Objects的hashCode方法

## 38、equals方法需要和hashCode相容，也就是说两者需要同相等、同时不等

## 39、toString方法也是Object基类的一个方法，其格式为类名+[字段=x，字段=y]，当用+连接字符串和一个对象的时候就会用该方法、println等方法也会使用

## 40、数组打印的时候用静态方法Arrays.toString。多维数组则需要deepToString

## 41、强烈建议每一个类都添加一个toString方法，利于日志的实现

## 42、牢记java中的==深刻含义是比较对象的内存地址是否一致，而equals方法需要确保比较的是内容的一。如果不覆写基类的equals方法，那么equals就用Object基类的equals方法，转为比较地址

## 43、和cpp不同，java允许在运行期确定一个数组的大小，也就是说，你可以new一个数组但是其大小是一个参数，这个在cpp中的栈数组是不允许的（除非参数已经在编译器确定值，即通过constexpr声明定义）

c++这样的目的是为了放置栈溢出，而对于堆内存分配的数组，其参数可以通过传参数的方式然后new出来

## 44、为了解决因为运行时候需要动态改变数组大小的问题，java提供了一个泛型数组列表

| **特性**                  | **Java** ArrayList<T>        | **C++** std::vector<T>            |
| ------------------------- | ---------------------------- | --------------------------------- |
| 编译原理                  | **泛型擦除**（type erasure） | **模板实例化**（compile-time）    |
| 是否真正生成 T 类型的数组 | ❌ 运行时统一为 Object[]      | ✅ 每种 T 会生成独立代码           |
| 类型安全                  | 运行时检查                   | 编译时强类型                      |
| 内存布局                  | 引用类型数组（堆上）         | 可能是连续内存（尤其是 POD 类型） |
| 性能                      | 有自动装箱开销               | 性能极高（尤其对基本类型）        |
| 是否支持原始类型如 int    | ❌ 必须用 Integer（装箱）     | ✅ vector<int> 是合法且高效的      |
| 可变性                    | 支持动态扩容                 | 支持动态扩容                      |
| 是否零开销泛型            | ❌（类型擦除 + 装箱）         | ✅（模板直接展开，几乎零开销）     |

## 45、通过菱形语法以及var避免写泛型类型

一个是在java10之后用var 另一个是左边如果已经明确制定类型，右边的泛型参数可以空着。如果左边已经用了var，右边就不可以空着泛型参数了

## 46、Vector在java的老版本中使用较为普遍，但是当前ArrayList的出现，Vector没有任何使用的必要了

| **特性**         | Vector                                | ArrayList          |
| ---------------- | ------------------------------------- | ------------------ |
| **线程安全**     | ✅ 内部方法全部 synchronized（代价大） | ❌ 非线程安全       |
| **性能**         | ❌ 较慢（同步开销大）                  | ✅ 快（无锁）       |
| **默认增长因子** | 2 倍                                  | 1.5 倍             |
| **API 设计**     | 很老，很多废弃接口                    | 设计现代，灵活性强 |
| **是否推荐使用** | ❌ 不推荐                              | ✅ 推荐使用         |

使用add方法为其后添加元素

可以通过ensureCapacity确保在给定范围内add不会出现开销很大的内存空间的重新分配、或者通过初始化构造器传入大小

## 47、new一个数组和new一个ArraryList时候都指定大小的区别

前者是new出来就有这么大空间可以使用，而后者只是可能保存那么多元素在初始化完成后是没有任何元素的

## 48、用泛型数组列表的size方法、数组的length方法

## 49、当已经确保之后不会再发生变化的数组大小的时候，使用trimToSize方法明确让垃圾回收器来回收剩余的内存空间

## 50、cpp的vector实现了重载[]，所以能通过下标访问值，但是java没有运算符重载，所以不能用这个访问值，而是使用get方法

## 51、cpp中的vector和java中的泛型数组列表使用=赋值给另一个相同对象的区别

前者是拷贝一份完全相同的vector，后者是让两者引用同一个数组列表

## 52、牢记set和get方法的关键点

由50点所说取值和赋值分别用这俩，但是set方法的时候，下标位置的值必须已经存在，也就是说它是修改值而不是赋值

当没有泛型类的原始的ArrayList时候，set的对象类型编译器不检查，但是这个时候因为get出来的东西必须强转类型，可能出错，例如set的时候传入的类型是一个String对象，但是get出来之后强转为一个Employee对象

## 53、方便的用[]访问泛型数组列表

即构造好了之后使用toArray方法给一个数组

## 54、明确ArrayList的性能开销：删除和插入都需要大量移动元素，老生长谈的问题

## 55、所有的基本类型都有与之对应的一个类，称其为包装器

Interget Long Short Float Byte Character Boolean Double

## 56、包装器类是不可变的，一旦构造就不允许更改其值。同时他们都是final类，不允许被继承

## 57、每个值分别包装到对象中，其Arraylist<Interger>效率远低于数组int[]

## 58、自动装箱和拆箱

为啥不用包装，是因为这个boxing来自c#

这俩的意思就是说，往一个Arraylist<Interger>中add一个int类型的值，list.add(3) 会被转为list.add(Interger.valueOf(3));

取值的是时候, list.get(0) => list.get(0).intValue();

## 59、以上也可以用于算术表达式

## 60、包装器类的比较

因为包装器类是对象类型，==比较的是内存地址，会导致都是1000的两个Interger在==判断失败，所以包装器类的比较用equals

## 61、特例：自动装箱规范要求boolean、byte、char<=127、介于-128到127之间的short和byte包装到固定的对象中，这个时候用==判断两个也能判断成功

## 62、包装器类可以为null，这个时候做运算抛出空指针异常

## 63、表达式混用Interger和Double类型会进行多次拆箱装箱影响性能，即先把Interger类型拆为int，然后转为double，再装箱为Double

## 64、牢记拆箱和装箱的是编译器的操作而非虚拟机

## 65、包装器类中存在一些静态方法，如将String转为int：Interger.parseInt(字符串)

## 66、想实现一个可以修改数值参数值的方法可以用holder持有者类型

## 67、可变参数可以用于基本类型和对象，表明其可以接受任意数量的对象。可以把数值传入可变类型参数

## 68、Java的枚举类中，其各个不同的类型其实是类的实例而非字段

```
public enum Color {
    RED, GREEN, BLUE;
}
```

其实是

```
	public final class Color extends Enum<Color> {
    public static final Color RED = new Color("RED", 0);
    public static final Color GREEN = new Color("GREEN", 1);
    public static final Color BLUE = new Color("BLUE", 2);

    private Color(String name, int ordinal) {
        super(name, ordinal);
    }

    public static Color[] values() { ... }
    public static Color valueOf(String name) { ... }
}
```

因此不可能构造新的对象出来，所以比较枚举值的时候只需要用==就可以了

## 69、需要的话，可以为枚举类提供构造函数、方法和字段。枚举的构造函数一定是私有的，否则报错。

## 70、枚举类的toString和valueOf为一对逆方法。

前者返回对应枚举类型的String表示，后者把对应的一个String转为枚举类型

Size s = Enum.valueOf(Size.class, "SMALL");

还有一个orfinal方法返回对应枚举类型的位置从0计数。compareTo则比较声明的位置

## 71、反射的定义：能够分析类的能力的程序称为一个反射

## 72、反射的作用：开发java工具代码的关键能力

### 1、运行时期检查类的能力

### 2、运行时期检查类的对象，例如编写一个适用于所有类的toString方法

### 3、实现一个泛型数组的操作代码

### 4、可以用来利用Method对象，这个东西类似cpp的函数指针

## 73、java为所有对象维护了一个运行时类型信息

## 74、Class类

使用Class类可以访问73点中的这些信息。Class对象可以描述一个特定类的属性

Employee e;

Class c = e.getClass();

可以通过类名获取类的对象。

String className = "java.util.Random";

Class c = Class.forName(className);

那么通过动态改变这个className就能动态获取Class对象，失败会抛出检查型异常：checked exception

## 75、对于任意的java类型，使用.class获取Class类对象

Class c = Romdom.class

## 76、Class类实际是泛型类，大多数时候可以忽略这个泛型，使用原始的Class类



