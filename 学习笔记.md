[TOC]



# 1、**WebSocket 与 纯 Socket（TCP）的核心区别**

| **特性/区别项** | **WebSocket**                      | **纯 Socket (TCP)**                        |
| --------------- | ---------------------------------- | ------------------------------------------ |
| 协议栈          | 应用层协议，基于 TCP               | 传输层协议（TCP）直接暴露                  |
| 握手方式        | HTTP 请求升级：Upgrade: websocket  | 无 HTTP 握手，通常直接由程序控制连接流程   |
| 使用对象        | 浏览器 / JS 原生支持               | 只能通过底层语言（C/C++/Java等）使用       |
| 连接建立权限    | 受限于同源策略、CORS               | 无浏览器安全限制                           |
| 编程复杂度      | 简单（前端new WebSocket(url)）     | 复杂，需要手动管理流、粘包、协议           |
| 消息边界        | 有明确的消息边界（帧）             | 没有，需自己定义协议格式                   |
| 安全性          | 支持 wss:// 加密                   | 需要手动集成 TLS                           |
| 默认端口        | ws: 80，wss: 443                   | 自定义，一般是任意非保留端口               |
| 应用场景        | IM、协同编辑、实时游戏、推送系统等 | 高性能原生应用、自定义协议传输、高频交易等 |

# 2、ws:// 和wss://

| ws://  | WebSocket（明文）        | ❌ 不加密            | 默认端口 80  |
| ------ | ------------------------ | ------------------- | ------------ |
| wss:// | WebSocket Secure（加密） | ✅ 基于 TLS/SSL 加密 | 默认端口 443 |

# **3、为什么客户端（浏览器、Electron 等）能识别？**

浏览器内置支持 WebSocket 协议，创建连接时使用：

const socket = new WebSocket('wss://example.com/ws');

```
这个 URI 是标准定义的一部分，浏览器会自动处理协议握手，包括：
	•	建立 TCP 连接
	•	发起 HTTP Upgrade 请求（从 HTTP/HTTPS 切换为 WebSocket 协议）
	•	建立全双工通道（像 socket 一样双向收发）

wss 的本质是：先用 HTTPS 握手，然后“升级”到 WebSocket 协议的加密版本
```

# 4、为什么不全用websocket

```
	1.	REST 更适合请求-响应模型
	•	获取用户资料、上传头像、获取新闻列表，这类操作天然就是「请求一下 → 给我响应」；
	•	用 REST + HTTP，配合浏览器缓存、CDN、负载均衡效率更高。
	2.	WebSocket 不走传统的 HTTP 基础设施
	•	不能走 CDN；
	•	很难缓存；
	•	基于长连接，服务端要维护状态（高并发下负担更重）；
	•	如果被 NAT / 防火墙断开，需要专门机制重连；
	3.	安全管控复杂
	•	REST 接口天然有很多 HTTP 安全机制可以复用（如 CORS、Auth headers、OAuth2）；
	•	WebSocket 鉴权得自己封装协议，一旦写错容易出安全漏洞。
	4.	调试和监控困难
	•	REST 请求天然可以抓包（curl / Charles），有标准日志格式；
	•	WebSocket 的数据是“全包体”，抓包、调试、排错更难，需要专门工具。
```

| **功能类型**             | **推荐方式** | **原因**           |
| ------------------------ | ------------ | ------------------ |
| 登录、注册、获取用户资料 | REST         | 简单、幂等、可缓存 |
| 拉取历史聊天记录         | REST         | 偶发请求、可分页   |
| 收发消息、推送           | WebSocket    | 实时性高           |
| 心跳、在线状态同步       | WebSocket    | 实时               |
| 图片上传、文件下载       | REST         | 有内容体、有 CDN   |

# 5、什么是CDN

CDN（Content Delivery Network，内容分发网络）是一个**分布式的缓存系统**，它的核心作用是：



> **让用户更快、更稳定地访问静态资源或网站内容**。

你的网站服务器在北京，有个广州的用户打开你的网站，加载首页时要从北京跨省去拉一张图片，速度慢、延迟高，还容易丢包。

**加了 CDN 后：**

- 这张图片会被缓存到广州本地的 CDN 节点上；
- 当广州用户请求这张图时，会直接从「广州 CDN 节点」拉数据，不用再跑去北京服务器。

CDN 一般用来缓存**不怎么变的资源**：

- 图片 / 视频 / 音频
- JS、CSS、字体文件
- Web 前端打包好的 HTML 文件
- 甚至 REST 接口的响应（例如新闻列表）

```
	1.	用户请求静态资源（如 https://cdn.example.com/logo.png）；
	2.	CDN 节点检查是否有缓存；
	•	有缓存 → 直接返回；
	•	没缓存 → 去源服务器拉一份，保存一份，再返回；
	3.	之后同样请求都会直接从 CDN 返回。
```

# 6、为什么说只有rest可以走CDN呢

说“只有 REST 可以走 CDN”并不是技术上的绝对限制，而是**出于 CDN 的设计目标、协议特性和工程现实的归纳总结**。下面我用直白 + 真实架构视角告诉你原因

| **协议/接口类型**      | **是否适合 CDN** | **原因**                   |
| ---------------------- | ---------------- | -------------------------- |
| REST (GET)             | ✅ 非常适合       | 可缓存、短连接、响应可预测 |
| REST (POST/PUT/DELETE) | 🚫 通常不缓存     | 有副作用，响应多变         |
| WebSocket              | 🚫 不适合         | 长连接、实时通信、无法缓存 |
| gRPC-stream / Socket   | 🚫 不适合         | 同样是持久连接             |

REST 的 GET 请求通常是：

- GET /api/news/today
- GET /api/user/123/profile

这些数据是**一段时间内稳定的**，可以被缓存几分钟甚至几小时 —— 非常适合 CDN 的缓存机制。

请求之间**无状态**，CDN 处理方便，边缘节点可以就近响应用户。

根本原因：无状态

# 7、gRPC和socket的关系

gRPC 和 socket 是两种完全不同层级和抽象的通信方式 —— 它们的**本质区别在于「协议层级」和「开发模型」**：

| **项目** | **gRPC**                              | **Socket**                  |
| -------- | ------------------------------------- | --------------------------- |
| 协议层级 | 应用层（基于 HTTP/2）                 | 传输层（TCP / UDP）         |
| 传输协议 | HTTP/2 + Protobuf                     | 原始 TCP/UDP                |
| 抽象程度 | 高，自动生成代码、支持服务/方法调用   | 低，需要自行管理连接、协议  |
| 支持特性 | 流控、多路复用、负载均衡、双向流、TLS | 全部手写（或自建）          |
| 典型场景 | 微服务通信、跨语言 RPC                | 聊天、游戏、IoT、实时推送等 |
| 复杂度   | 接近「调用函数」级别                  | 接近「操作裸字节流」级别    |

也就是说一个是封装成函数级别了，另一个需要自己拿出来消息解析消息内容再做处理，gRPC相当于是在socket上的封装

gRPC 本质是为 服务间调用 而设计，socket 是为 通信连接 而设计

```
	•	gRPC 最适合的场景是后端服务间调用，例如：
	•	用户服务调用订单服务
	•	文件服务请求认证服务
	•	而 socket 是为高实时通信设计的，比如：
	•	聊天系统（IM）
	•	游戏联机
	•	实时行情推送
	•	视频弹幕、直播弹幕
```

# 8、为啥游戏系统不用websocket而生原生socket呢

**核心原因可以归结为三个字：性能、控制、灵活性。**

**延迟敏感性极高（WebSocket 传输开销大）**

- WebSocket 基于 HTTP 升级建立连接，且**每个数据包都有头部开销**（掺杂帧结构等）。
- FPS、MOBA 类游戏要求 **几十毫秒级的响应时间**，WebSocket 的封装 +底层 TCP 三次握手、拥塞控制等导致延迟波动大。

✅ 所以游戏常用 UDP 或自定义 TCP 协议来规避这些问题。

原生 socket（尤其是 UDP）能实现：

| **功能**                 | **WebSocket 是否支持** | **原生 socket 是否支持** |
| ------------------------ | ---------------------- | ------------------------ |
| 自定义可靠性机制         | ❌ 不支持               | ✅ 支持（尤其是 UDP）     |
| 控制重传 / 丢包处理逻辑  | ❌ 不支持               | ✅ 支持                   |
| 细粒度传输优化（如 MTU） | ❌ 不支持               | ✅ 支持                   |
| 半连接/无连接模式        | ❌ 仅全双工连接         | ✅ TCP/UDP 自由选择       |

# 9、Websocket从http升级的时候，之后的消息还是会用http格式还是全新的消息格式呢

**WebSocket 握手（Upgrade）阶段**

1. **客户端发起 HTTP 请求**，带上特殊的头部 Upgrade: websocket，表示想升级协议：

   ```
   GET /chat HTTP/1.1
   Host: server.example.com
   Upgrade: websocket
   Connection: Upgrade
   Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
   Sec-WebSocket-Version: 13
   ```

   

2. **服务器响应**，同意升级，返回 HTTP 101 Switching Protocols 状态码：

```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

**升级成功后 — 消息格式变了**

- **此后客户端和服务器间的数据传输**不再使用 HTTP 格式（无请求行、无头部、无状态码），
- 而是使用**WebSocket 帧（frame）格式**，一种专门设计的二进制消息格式。

**WebSocket 帧的结构（RFC 6455）**

每条消息封装成一组帧，主要字段（简化版）：

| **字段名**   | **长度（位）** | **说明**                                      |
| ------------ | -------------- | --------------------------------------------- |
| FIN          | 1              | 是否为消息的最后一帧                          |
| RSV1-3       | 3              | 保留位（一般为0）                             |
| Opcode       | 4              | 帧类型，如文本(0x1)、二进制(0x2)、关闭(0x8)等 |
| Mask         | 1              | 是否对数据进行了掩码处理（客户端必须掩码）    |
| Payload Len  | 7/16/64        | 负载长度                                      |
| Masking-key  | 0 或 32        | 掩码密钥                                      |
| Payload Data | 可变           | 实际消息数据                                  |

- **客户端发送文本消息 "Hello"：**

二进制帧数据（简化伪代码）：

```
0x81 0x85 <masking-key(4 bytes)> <masked "Hello" bytes>
```

WebSocket 协议层在 TCP 连接上独立运行，不涉及 HTTP 的请求行和响应头

# 10、掩码在websocket协议里面的作用是什么呢？

掩码（masking）在 WebSocket 协议里**并不提供安全保护**，它只是防止代理服务器缓存和篡改数据的机制，而不是加密。

简单来说：

- 掩码只是一个简单的异或操作，黑客如果截获数据和掩码，**很容易恢复原始内容**。
- 它的目的**不是防止窃听或破解**，而是防止代理缓存“误判”WebSocket数据为普通HTTP内容。
- 如果你想防止黑客窃听或篡改，必须用 **TLS（即WSS协议）** 来加密通信。
- WSS 是 HTTPS 上的 WebSocket，数据在传输过程中被加密，第三方无法轻易解密。

# 11、用wss的时候，消息体格式是什么样子

简单说，WSS（WebSocket Secure）是在 WebSocket 基础上加了 TLS 加密层。消息体本质上还是**WebSocket帧**的格式，只不过：

- 传输层被 TLS 加密了，网络上的数据包是加密的，看不懂。
- TLS 在 WebSocket帧**外层**，客户端和服务器之间建立安全通道。
- WebSocket协议的帧结构、掩码、分片等机制不变，但数据内容在传输时被 TLS 加密

# 12、TLS加解密原理是什么

### **1.** **握手阶段（Handshake） — 建立安全通道**

TLS连接的第一步是握手，双方协商加密算法、生成密钥。

- **客户端Hello**：客户端发送支持的TLS版本、加密套件列表、随机数（Client Random）等信息。

- **服务器Hello**：服务器选择TLS版本、加密套件，返回服务器证书（包含公钥）、随机数（Server Random）。

- **服务器证书验证**：客户端验证服务器证书的合法性（是否被受信任的CA签名，是否过期等）。

- **密钥协商**：

  

  - 传统TLS（如RSA）由客户端生成一个“预主密钥”（Pre-Master Secret），用服务器公钥加密发给服务器，服务器用私钥解密得到预主密钥。
  - 现代TLS（如ECDHE）使用椭圆曲线Diffie-Hellman交换算法，双方协商一个共享密钥。

  

- **生成会话密钥**：客户端和服务器用握手中的随机数和预主密钥，独立计算出相同的对称加密密钥（Session Key）。

握手成功后，双方使用**对称密钥**加密后续通信数据，极大提升效率。

### **2.** **对称加密通信**

- 之后所有通信数据都用协商好的对称加密算法（如AES）和密钥加密。
- 对称加密速度快，适合传输大量数据。
- 每条消息还会带有消息认证码（MAC）保证数据完整性。

### 3、**消息认证**

- 使用消息认证码（MAC）或基于AEAD的加密（如AES-GCM）同时完成加密和完整性校验，防止数据被篡改。
- 收到消息后，接收方先校验MAC，确保数据未被篡改，再解密。

### 4、**证书和身份认证**

- 服务器通过CA签发的证书证明自己的身份，客户端通过验证证书保证自己连接的是目标服务器，防止中间人攻击。

# 13、为啥他们沟通的密钥只有他们双方知道呢？密钥本身如何被加密呢？

### **1. 非对称加密保护密钥（RSA密钥交换）**

在早期TLS版本中，密钥交换通常用RSA：

- 客户端生成一个随机的“预主密钥”（Pre-Master Secret）。
- 用服务器的**公钥**加密这个预主密钥，然后发给服务器。
- 服务器用自己的**私钥**解密得到预主密钥。

因为只有服务器有私钥，别人截获了密文没法解密，**密钥本身通过非对称加密被保护**。

### **2. Diffie-Hellman密钥交换（DH/ECDHE）——双方各自生成秘密参数，协商共享密钥**

现代TLS（TLS 1.2/1.3）更推荐使用**Ephemeral Diffie-Hellman（临时DH）**，简称ECDHE：

- 双方分别生成一个私有秘密值（私钥），并计算对应的公钥（公开给对方）。
- 通过交换公钥，各自用自己的私钥和对方的公钥计算出相同的共享密钥（Session Key）。
- 这个共享密钥**没有直接传输**，即使第三方截获了所有通信数据，包括公钥，也无法计算共享密钥（这是数学难题）。

所以这里的“密钥只有双方知道”是因为共享密钥是**双方私钥和对方公钥计算出来的**，而私钥绝不会离开各自设备。

# 14、为什么各自的私钥和对方的公钥算出来的共享密钥是相同的呢？

假设：

- 公共参数是一个大质数 p 和一个生成元 g，公开给双方。
- **Alice** 选择一个私钥 a，计算公钥 A = g^a \mod p，把 A 发送给 Bob。
- **Bob** 选择一个私钥 b，计算公钥 B = g^b \mod p，把 B 发送给 Alice

![image-20250606234924587](https://raw.githubusercontent.com/t1m3saver/picBed/main/mac/image-20250606234924587.png)

![image-20250606235013548](https://raw.githubusercontent.com/t1m3saver/picBed/main/mac/image-20250606235013548.png)

# 15、TLS握手建立完安全通道之后，基于这个通道的HTTP通信还需不需要三次握手？

答案是：**不需要了**。

详细解释：

- **TCP三次握手**是建立TCP连接的，是网络层的事情。
- **TLS握手**是在已经建立的TCP连接基础上，协商加密参数，建立安全会话。
- **HTTP通信**（比如HTTPS）是在TLS连接之上的应用层数据传输。

所以：

- 三次握手只发生一次，是TCP连接建立时。
- TLS握手紧接着TCP连接建立完成后进行。
- 之后的所有HTTP请求和响应都是在这条已经建立的安全TCP连接（TLS通道）里传输的。

举个类比：

TCP三次握手像是打开了电话线路；TLS握手像是双方约定说用加密语言交流；之后的HTTP数据就是这条加密线路上的“电话交谈”。通话期间不需要再重新建立电话线路（三次握手）。

**如果HTTP连接断开（TCP断开），重新连接时才会重新三次握手，紧接着TLS握手，然后HTTP通信。**

# 16、利用drogon库的websocket例子

```cpp
#include <drogon/drogon.h>

class MyWebSocketHandler : public drogon::WebSocketController<MyWebSocketHandler>
{
public:
    // 绑定路由，匹配 /ws 路径的 WebSocket 请求
    void handleNewConnection(const drogon::WebSocketConnectionPtr &conn) override
    {
        LOG_INFO << "New WebSocket connection established: " << conn->getPeerAddr().toIpPort();
    }

    void handleConnectionClosed(const drogon::WebSocketConnectionPtr &conn) override
    {
        LOG_INFO << "WebSocket connection closed: " << conn->getPeerAddr().toIpPort();
    }

    void handleMessage(const drogon::WebSocketConnectionPtr &conn,
                       std::string &&message,
                       const drogon::WebSocketMessageType &type) override
    {
        LOG_INFO << "Received message: " << message;
        // 简单回显收到的消息
        if (type == drogon::WebSocketMessageType::Text)
        {
            conn->send(message);
        }
        else if (type == drogon::WebSocketMessageType::Binary)
        {
            conn->send(std::move(message), drogon::WebSocketMessageType::Binary);
        }
    }

    WS_PATH_LIST_BEGIN
        WS_PATH_ADD("/ws")  // 监听 /ws 路径
    WS_PATH_LIST_END
};

int main()
{
    // 注册 WebSocket 控制器
    drogon::app().registerController(std::make_shared<MyWebSocketHandler>());

    // 监听端口，启动服务
    drogon::app().addListener("0.0.0.0", 8080);
    drogon::app().run();

    return 0;
}
```

收到的参数为string，但是type 是以下三种之一：

| **枚举值**                   | **含义**                 |
| ---------------------------- | ------------------------ |
| WebSocketMessageType::Text   | 文本消息（UTF-8 字符串） |
| WebSocketMessageType::Binary | 二进制消息（任意字节流） |
| WebSocketMessageType::Pong   | Pong 控制帧（应答 Ping） |

- 对于 Binary 类型，虽然是 std::string 类型，你不能直接当 UTF-8 文本来处理，应以字节方式解析。
- Drogo 是为了方便，统一用 std::string 存储字节内容，但你要自己区分 Text 与 Binary。

# 17、所以我其实有必要在websocket层上包装协议吗

**原因不是 WebSocket 不够用，而是它提供的是“低层通信通道”，需要你自己定义上层语义。**

WebSocket 本身只定义了：

- 建立连接、收消息、发消息（文本 / 二进制）；
- 没有内建的消息格式、命令字、状态码、序列号等机制；
- 没有区分“登录消息”、“心跳消息”、“聊天消息”等。

**你必须构建自己的协议语义层，否则前后端根本无法协同工作。**

#### **1.** **JSON 协议封装（简单易调试）**

```
{
  "type": "chat_message",
  "from": "user123",
  "to": "user456",
  "timestamp": 1728391723,
  "content": "Hello!"
}
```

- 客户端、服务端解析 type 字段进行分发；
- 可以支持 ping / pong / auth / chat_message / logout 等类型；
- 容易扩展，适合中小型系统。

#### 2、**protobuf 或自定义二进制协议（高性能 + 安全）**

```
message Packet {
  required uint32 type = 1; // 登录、心跳、消息、通知等
  required bytes payload = 2;
}
```

- 每个 type 映射一种 payload 的反序列化格式；
- 能节省字节开销、加快处理速度；
- 配合 protobuf、flatbuffers 等工具生成代码