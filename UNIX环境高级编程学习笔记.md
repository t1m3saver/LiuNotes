# UNIX环境高级编程学习笔记

## 1、unix和linux的关系

Unix 和 Linux 的关系可以用一句话概括：**Linux 是一个“类 Unix”系统，它继承了 Unix 的设计思想，但并不是 Unix 的直接后代。Linux 是受 Unix 启发并高度兼容 POSIX 的自由开源系统，是 Unix 精神的继承者，而非其技术克隆**

## 2、那啥是POSIX呢

> **POSIX（Portable Operating System Interface）是一套操作系统接口标准，规定了“像 Unix 那样”的行为方式。**

说白了，就是一种标准

## 3、口令文件/etc/passwd

| **字段位置** | **含义**                           |
| ------------ | ---------------------------------- |
| 1            | 用户名（如 root）                  |
| 2            | 密码占位符（以前是明文，现在是 x） |
| 3            | UID（用户ID）                      |
| 4            | GID（组ID）                        |
| 5            | 用户描述（备注）                   |
| 6            | 主目录路径                         |
| 7            | 默认 shell                         |

现在密码信息已经被分离出来，放到 /etc/shadow 文件中。

**这个文件权限严格受限**，通常只有 root 可读

## 4、标准输入、输出、错误，其实都是文件描述符fd

- 当你 printf("hello") 或 cout << "hello"; 的时候，

  

  - 底层是调用 write(1, "hello", 5)，
  - 操作系统把数据写到了 /dev/tty 这个设备文件上，
  - 然后你在屏幕上看到了“hello”

也就是说，也是在写文件呢。贯彻了一切都是在写文件

## 5、/dev下的设备文件是操作系统为设备驱动暴露出来的访问接口

它本身只是个门牌号（metadata + 一个 major:minor 号），真正干活的是后面的**驱动程序**。



**不是磁盘，不是屏幕，不是键盘自己管理自己，是驱动在管。**



所以：



- /dev/tty -> 是**终端设备驱动**在管理。
- /dev/sda -> 是**磁盘设备驱动**在管理。
- /dev/fb0 -> 是**显存framebuffer驱动**在管理。
- /dev/input/event0 -> 是**输入设备驱动**（键盘、鼠标）在管理。

设备文件本身什么都不做，是内核拿它**做跳板**，调到对应设备驱动的操作函数（read、write、ioctl、mmap…）。

## 6、**就算你只写了1字节，磁盘实际上也要按”块”单位读-改-写一整块。**

| **原因**     | **解释**                                                     |
| ------------ | ------------------------------------------------------------ |
| 硬件物理限制 | 磁盘、固态硬盘，物理上只能按固定大小（比如512B, 4KB）操作。  |
| 效率与寿命   | 频繁写1字节会严重降低硬盘/SSD寿命，按块写可以均衡负载、延长寿命。 |
| 文件系统设计 | Ext4、XFS、NTFS等文件系统都是基于块的抽象和管理来的。        |

- 把对应的整个块（比如4KB）读进内存
- 修改其中1字节
- 把整块重新写回磁盘

这叫 **读-改-写**（read-modify-write）过程。

## 7、为什么磁盘需要先读了再写

想象一下极端情况：



- 第100字节要写字母’A’。
- 但这100字节属于第3个块（比如第3个4KB块）。
- 如果你直接write(1 byte)，你只能提交这1 byte数据给磁盘。
- 磁盘内部要求是**一整块**（4096字节），你只给了1字节，剩下的4095字节它拿什么填？
- 结果就是：**剩余部分会变成随机垃圾或者清零。**



换句话说：



> 你如果不先读回来整个块的原始数据，就无法保证**修改后的块**仍然是正确的。

比如数据库系统（MySQL, RocksDB）经常这么干。



> **只要你覆盖了整个块，内核就可以直接write，不用r-m-w。**



所以性能优化经常讲：



- 尽量按块对齐写入。
- 尽量写大块数据，避免碎片小写。



## 8、内核通过7个函数将一个可执行文件载入内容中

## 9、进程控制的核心三函数：exec、fork、waitpid

## 10、ctrl d是默认的文件结束符

## 11、“一个进程内的所有线程共享同一地址空间、文件描述符、栈以及与进程相关的属性”

## 12、组文件/etc/group

包含了组名和组id的映射关系

## 13、getuid与getgid分别是用户id和组id

## 14、一个用户至少支持16个附属组

## 15、信号处理有三种方式：按系统默认、忽略信号、提供处理函数

## 16、ctrl + \表示退出

## 17、向一个进场发送信号的时候，要么是所有者要么是root

## 18、3个时间

“当度量一个进程的执行时间时（见3.9节），UNIX系统为一个进程维护了3个进程时间值：
•时钟时间；
•用户CPU时间；
•系统CPU时间。
时钟时间又称为墙上时钟时间（wall clock time），它是进程运行的时间总量，其值与系统中同时运行的进程数有关。每当在本书中提到时钟时间时，都是在系统中没有其他活动时进行度量的。
用户CPU时间是执行用户指令所用的时间量。系统CPU时间是为该进程执行内核程序所经历的时间。例如，每当一个进程执行一个系统服务时，如read或write，在内核内执行该服务所花费的时间就计入该进程的系统CPU时间。用户CPU时间和系统CPU时间之和常被称为CPU时间。
要取得任一进程的时钟时间、用户时间和系统时间是很容易的—只要执行命令 time(1)，其参数是要度量其执行时间的命令”

摘录来自
UNIX环境高级编程(第3版)
[美]W. Richard Stevens Stephen A. Rago 著
此材料可能受版权保护。

## 19、“Linux 3.2.0提供了380个系统调用，FreeBSD 8.0提供的系统调用超过450个。”

摘录来自
UNIX环境高级编程(第3版)
[美]W. Richard Stevens Stephen A. Rago 著
此材料可能受版权保护。

## 20、“文件描述符的变化范围是0～OPEN_MAX-1（见图2-11）。早期的UNIX系统实现采用的上限值是19（允许每个进程最多打开20个文件），但现在很多系统将其上限值增加至63。”

摘录来自
UNIX环境高级编程(第3版)
[美]W. Richard Stevens Stephen A. Rago 著
此材料可能受版权保护。
